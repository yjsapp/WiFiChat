package com.ty.winchat.listener;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import org.json.JSONException;
import org.json.JSONObject;

import android.util.Log;


import com.ty.winchat.WinChatApplication;
import com.ty.winchat.listener.inter.OnUDPReceiveMessage;
import com.ty.winchat.model.UDPMessage;
import com.ty.winchat.model.User;
import com.ty.winchat.ui.Set;
import com.ty.winchat.util.Constant;
import com.xbc.Audio.AudioInfo;
import com.xbc.Video.VideoInfo;
import com.xbc.control_message.MessageInfo;

/**
 * 文本消息收发器
 *
 */
public class UDPMessageListener extends UDPListener{
	
	//文本消息监听端口
	private final int port=Constant.MESSAGE_PORT;
	private final int BUFFER_SIZE=1024*3;//3k的数据缓冲区
	private OnUDPReceiveMessage onReceiveMessage;
	//保存当前在线用户，键值为用户的ip
	 final Map<String,User> users;
	//保存用户发的消息，每个ip都会开启一个消息队列来缓存消息
	 final Map<String, Queue<UDPMessage>> messages;
	
	private static UDPMessageListener instance;
	
	
	private UDPMessageListener(Map<String,User> users,Map<String, Queue<UDPMessage>> messages){
		this.users=users;
		this.messages=messages;
	}
	
	public static UDPMessageListener getInstance(Map<String,User> users,Map<String, Queue<UDPMessage>> messages){
		return instance==null?instance=new UDPMessageListener(users,messages):instance;
	}
	
	@Override
  void init() {
		setPort(port);
		setBufferSize(BUFFER_SIZE);
  }
	
  @Override
  public void onReceive(byte[] data, DatagramPacket packet) {
    try {
	    String temp=new String(data, 0, packet.getLength(), Constant.ENCOD);//得到接收的消息
	    UDPMessage msg = new UDPMessage(new JSONObject(temp));
//	    Log.d("====", "收到消息："+msg.toString());
	    String sourceIp=packet.getAddress().getHostAddress();//对方ip
	    int type=msg.getType();
	    switch (type) {
				case ADD_USER://增加一个用户
					User user=new User();
					user.setIp(sourceIp);
					user.setUserName(msg.getSenderName());
					user.setDeviceCode(msg.getDeviceCode());
					//构造回送报文内容
					if(!WinChatApplication.mainInstance.getLocalIp().equals(user.getIp())){
						users.put(sourceIp, user);
						send(WinChatApplication.mainInstance.getMyUdpMessage("", LOGIN_SUCC).toString(), packet.getAddress());
					}
					break;
					
				case LOGIN_SUCC://在对方登陆成功后返回的验证消息
					user=new User();
					user.setIp(sourceIp);
					user.setUserName(msg.getSenderName());
					user.setDeviceCode(msg.getDeviceCode());
					users.put(sourceIp, user);
					break;
					
				case REMOVE_USER://删除用户
					users.remove(sourceIp);
					break;
					
				case ASK_VIDEO:
					
					
					
				case REPLAY_VIDEO_ALLOW:
					
				case REPLAY_VIDEO_NOT_ALLOW:
					
				case REPLAY_SEND_FILE://回复文件传输邀请
					
				case ASK_SEND_FILE://收到文件传输邀请
					
				case RECEIVE_MSG://接收到消息
					
					
					System.out.println("------------收到消息了");
					System.out.println(msg.getMsg());
					String[] whole=msg.getMsg().split("/");
					String main=whole[0];
					
					if(main.equals(MessageInfo.audio_call)){
					
					 android.os.Message LaiDian=new android.os.Message();	//创建handler消息
					 LaiDian.arg1=1;
					AudioInfo.Called.sendMessage(LaiDian);
					
					AudioInfo.ChatIp=whole[1];
					
					}
					
					
					else if(main.equals(MessageInfo.audio_off_1))	{
						
						System.out.println("对方未接听直接挂断");
						
						
						 android.os.Message guaduan=new android.os.Message();	//创建handler消息
						 guaduan.arg1=1;
						AudioInfo.Audio_Off_1.sendMessage(guaduan);	
						
						}
					
else if(main.equals(MessageInfo.audio_off_2))	{
						
						System.out.println("对方接听后挂断");
						
						
						 android.os.Message guaduan=new android.os.Message();	//创建handler消息
						 guaduan.arg1=1;
						AudioInfo.Audio_Off_2.sendMessage(guaduan);	
						
						}	
					
else if(main.equals(MessageInfo.audio_listen))	{
	
	System.out.println("对方接起电话了");
	
	
	 android.os.Message  jieting =new android.os.Message();	//创建handler消息
	 jieting.arg1=1;
	AudioInfo.Audio_Listen.sendMessage(jieting);	
	
	}	
else if(main.equals(MessageInfo.video_call))	{
	
	System.out.println("对方有视频请求");
	AudioInfo.ChatIp=whole[1];
	
	 android.os.Message  shipin =new android.os.Message();	//创建handler消息
	 shipin.arg1=1;
	VideoInfo.Called.sendMessage(shipin);	
	
	}					
		
else if(main.equals(MessageInfo.video_ok))	{
	
	System.out.println("对方同意视频请求");
	
	
	 android.os.Message  shipin_ok =new android.os.Message();	//创建handler消息
	 shipin_ok.arg1=1;
	VideoInfo.Video_Play.sendMessage(shipin_ok);	
	
	}						
					
else if(main.equals(MessageInfo.video_off_2))	{
	
	System.out.println("对方结束视频聊天");
	
	VideoInfo.endView=true;
		
	
	}							
					
					
					
				
					
					
					
//					if(messages.containsKey(sourceIp)){
//						messages.get(sourceIp).add(msg);//更新现有
//					}else{
//						Queue<UDPMessage> queue=new ConcurrentLinkedQueue<UDPMessage>();
//						queue.add(msg);
//						messages.put(sourceIp, queue);//新增
//					}
					break;
					
				case TO_ALL_MESSAGE://message to all
					if(messages.containsKey(Constant.ALL_ADDRESS)){
						messages.get(Constant.ALL_ADDRESS).add(msg);//更新现有
					}else{
						Queue<UDPMessage> queue=new ConcurrentLinkedQueue<UDPMessage>();
						queue.add(msg);
						messages.put(Constant.ALL_ADDRESS, queue);//新增
					}
					break;
					
				case HEART_BEAT://心跳包检测
					send(WinChatApplication.mainInstance.getMyUdpMessage("", HEART_BEAT_REPLY).toString(), packet.getAddress());//回复心跳包
					user=users.get(sourceIp);
					if(user!=null){
						user.setHeartTime(System.currentTimeMillis()+"");
						Log.e("UDPMessageListener", "接收心跳包："+user.getHeartTime());
					}
					break;
					
				case HEART_BEAT_REPLY://接收到心跳包
					user=users.get(sourceIp);
					if(user!=null)
						user.setHeartTime(System.currentTimeMillis()+"");//更新心跳包的最后时间
					break;
					
				case REQUIRE_ICON://请求头像
					File file=new File(WinChatApplication.iconPath+Set.iconName);
					if(file.exists()){
						TCPFileListener listener=TCPFileListener.getInstance();
						if(!listener.isRunning()){
							try {
								listener.open();
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
						listener.sendFile(sourceIp, file, WinChatApplication.iconPath,WinChatApplication.mainInstance.getDeviceCode());
					}
					break;
			}
	    if(onReceiveMessage!=null)
	    	onReceiveMessage.onReceive(type);
    } catch (UnsupportedEncodingException e) {
    	e.printStackTrace();
	}catch (JSONException e) {
		e.printStackTrace();
	}
  }


	@Override
  void noticeOffline() {
		try {
			send(WinChatApplication.mainInstance.getMyUdpMessage("", REMOVE_USER).toString(), InetAddress.getByName(Constant.ALL_ADDRESS));
		} catch (UnknownHostException e) {
			e.printStackTrace();
		}
  }
	
	@Override
	public void noticeOnline(){
		try {
			send(WinChatApplication.mainInstance.getMyUdpMessage("", ADD_USER).toString(), InetAddress.getByName(Constant.ALL_ADDRESS));
		} catch (UnknownHostException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * 发送UDP数据包
	 * @param msg  消息
	 * @param destIp  目标地址
	 * @param destPort  目标端口
	 * @throws IOException 
	 */
	public void send(String msg, InetAddress destIp){
//		Log.d("====", "发送消息："+msg);
		send(msg, destIp, Constant.MESSAGE_PORT);
	}

	public OnUDPReceiveMessage getOnReceiveMessage() {
  	return onReceiveMessage;
  }

	public void setOnReceiveMessage(OnUDPReceiveMessage onReceiveMessage) {
  	this.onReceiveMessage = onReceiveMessage;
  }
	
	@Override
	public void close() throws IOException {
		super.close();
		//这个一定要置空，不然会出现already start的bug,因为instance是static的，程序退出后，当前dvm还在，还是会保持对原有变量的引用
		instance=null;
		if(users!=null)	users.clear();
		if(messages!=null)	messages.clear();
	}

	@Override
	void sendMsgFailure() {
		 if(onReceiveMessage!=null)
			 onReceiveMessage.sendFailure();
	}

}
